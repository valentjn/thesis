import os
import subprocess
import warnings

# paper size of manuscript version in mm (A4), width/height
manuscriptPaperSize = (210, 297)
# additional page margins for each side in mm, left/bottom/right/top
manuscriptMargins   = (3, 3, 3, 3)

# paper size of published version in mm (A5), width/height
publishedPaperSize  = (148, 210)
# additional page margins for each side in mm, left/bottom/right/top
publishedMargins    = (3, 3, 3, 3)

# metadata for the print-version PDFs
metaData = {
  "title" : "B-Splines for Sparse Grids: "
            "Algorithms and Application to Higher-Dimensional Optimization",
  "author" : "Julian Valentin",
  "keywords" : ["B-splines", "sparse grids", "optimization"],
}

# ICC color profile
iccProfile = {
  "path" : os.path.join("..", "..", "misc", "ISOcoated_v2_300_eci.icc"),
  "outputIntent" : r"ISO Coated v2 300\% (ECI)",
  "identifier"   : r"ISO Coated v2 300\% (ECI)",
  "registryURL"  : "http://www.fogra.org/"
}



def generatePrintTex(target, source, env):
  pdf, tex = source[0].abspath, target[0].abspath
  print(pdf, tex)
  
  if "manuscript" in os.path.basename(tex).lower():
    paperSize, margins = manuscriptPaperSize, manuscriptMargins
  else:
    paperSize, margins = publishedPaperSize,  publishedMargins
  
  pointsPerMillimeter = 72 / 25.4
  texContents = r"""
\RequirePackage{{filecontents}}
\begin{{filecontents*}}{{\jobname.xmpdata}}
  \Title{{{}}}
  \Author{{{}}}
  \Keywords{{{}}}
  \setCMYKcolorprofile{{{}}}{{{}}}{{{}}}{{{}}}
\end{{filecontents*}}
\documentclass{{article}}
\usepackage[papersize={{{}mm,{}mm}}]{{geometry}}
\usepackage[x-3]{{pdfx}}
\pdfpageattr{{/TrimBox [{} {} {} {}]}}
\usepackage{{pdfpages}}
\begin{{document}}
  \includepdfmerge[trim=-{}mm -{}mm -{}mm -{}mm,clip=true]{{{},3-}}
\end{{document}}
""".format(
      metaData["title"], metaData["author"],
      r"\sep ".join(metaData["keywords"]),
      iccProfile["path"], iccProfile["outputIntent"],
      iccProfile["identifier"], iccProfile["registryURL"],
      paperSize[0] + margins[0] + margins[2],
      paperSize[1] + margins[1] + margins[3],
      pointsPerMillimeter * margins[0],
      pointsPerMillimeter * margins[1],
      pointsPerMillimeter * (paperSize[0] + margins[0]),
      pointsPerMillimeter * (paperSize[1] + margins[1]),
      *margins, pdf,
  )
  with open(tex, "w") as f: f.write(texContents)




Import("env")
Import("Helper")
env = env.Clone()

# check for pdfjam
hasPDFJam = Helper.checkProgramInstalled(env, "pdfjam")
if not hasPDFJam:
  warnings.warn("pdfjam required for producing print versions. "
                "Skipping generation of print versions.")

pdfsPrint  = []
pdfsScreen = []

# install cover PDFs (generated by gfx/SConscript) in out/
coverPrintPDF  = env.Install(
    ".", os.path.join(env["BUILD_DIR"].abspath,
                      "..", "gfx", "coverPrint.pdf"))
coverScreenPDF = env.Install(
    ".", os.path.join(env["BUILD_DIR"].abspath,
                      "..", "gfx", "coverScreen.pdf"))
pdfsPrint.append(coverPrintPDF)
pdfsScreen.append(coverScreenPDF)

# install PDF generated by LuaLaTeX as manuscript screen version
thesisManuscriptScreen = env.InstallAs(
    "thesisManuscriptScreen.pdf", env["BUILD_PDF"])
env.AddPostAction(thesisManuscriptScreen, Helper.compressPDFs)
pdfsScreen.append(thesisManuscriptScreen)

if hasPDFJam:
  env.Replace(PDFLATEX="python3 ../../tools/filterOutput.py pdflatex")
  
  for name, paperSize, margins in zip(
            ["thesisManuscriptPrint", "thesisPublishedPrintA5"],
            [manuscriptPaperSize, publishedPaperSize],
            [manuscriptMargins,   publishedMargins]):
    printTex = env.Command(
        os.path.join(env["BUILD_DIR"].abspath, "{}.bla.tex".format(name)),
        env["BUILD_PDF"], generatePrintTex)
    pdf = env.PDF(
        os.path.join(env["BUILD_DIR"].abspath, "{}.bla.pdf".format(name)),
        printTex)
    pdf = env.InstallAs(os.path.join(".", "{}.pdf".format(name)), pdf)
    pdfsPrint.append(pdf)
  
  # generate published 2-up version
  thesisNupRotated = os.path.join(env["BUILD_DIR"].abspath,
                                  "thesisNupRotated.pdf")
  thesisNupWithoutCover = os.path.join(env["BUILD_DIR"].abspath,
                                       "thesisNupWithoutCover.pdf")
  env.Command(thesisNupRotated, env["BUILD_PDF"],
      "pdfjam --quiet --keepinfo --nup 2x1 --landscape --outfile $TARGET "
      "$SOURCE '2-'")
  thesisPublishedPrintA4Nup = env.Command(
      "thesisPublishedPrintA4Nup.pdf", thesisNupRotated,
      "pdfjam --quiet --keepinfo --angle 90 --outfile $TARGET $SOURCE")
  env.AddPostAction(thesisPublishedPrintA4Nup, Helper.compressPDFs)
  pdfsPrint.append(thesisPublishedPrintA4Nup)

# don't clean PDFs in out directory
env.NoClean(pdfsPrint + pdfsScreen)

# create aliases for generating print, screen, or all versions
env.Alias("all", ".")
env.Alias("print", pdfsPrint)
env.Alias("screen", pdfsScreen)

# generate by default (if invoked with just `scons`) only the screen version
env.Default("screen")
