\section{Algorithms}
\label{sec:82algorithms}

This section gives an overview of the algorithms that
were used to implement the solution process of
the discretized Bellman equation \eqref{eq:gridBellman}.



\subsection{General Structure}
\label{sec:821generalStructure}

The general approach to solve dynamic portfolio choice models is as follows:
\begin{enumerate}
  \item
  Generation of value function interpolants $\valueintp_t$
  (\texttt{solveValueFunction}, \cref{alg:financeSolveValueFunction})
  
  \item
  Generation of optimal policy interpolants $\optpolicyintp_t$
  (\texttt{solvePolicy}, \cref{alg:financeSolvePolicy})
  
  \item
  Computation of Euler equation errors
  (\texttt{computeEulerErrors}, \cref{alg:computeEulerErrors})
\end{enumerate}
The separation of the solution processes for
the value function interpolants $\valueintp_t$
and the optimal policy interpolants $\optpolicyintp_t$
enables to generate different spatially adaptive sparse grids
for the value function and the optimal policies.
This is useful if the shapes of value function and optimal policies
have different characteristics.

In the following (\cref{%
  sec:822optimization,%
  sec:823interpolation,%
  sec:824quadrature,%
  sec:825gridGeneration%
}), we first describe the algorithmic details of
\texttt{solveValueFunction} (step 1).
The treatment of the other steps \texttt{solvePolicy} (step 2) and
\texttt{computeEulerErrors} (step 3) follows with
\cref{sec:826policyGeneration} and \cref{sec:827eulerEquationErrors},
respectively.

We track two interpolants $\valueintp[1]_t$ and $\valueintp[p]_t$
for each $t = 0, \dotsc, T$.
The former interpolates the value function data at the grid points
with the hierarchical piecewise linear basis
(used for the surplus-based grid generation),
while the latter interpolates the data with hierarchical B-splines
of higher order $p > 1$.
Each $\valueintp[\ast]_t$ ($\ast \in \{1, p\}$)
additionally stores the grid points $\state_t^{(k)}$
and the optimal policies $\optpolicyintp_t(\state_t^{(k)})$
at the grid points ($k = 1, \dotsc, \ngp_t$).
For simplicity, we do not pass them as separate data
to the algorithms.

\paragraph{\texttt{solveValueFunction}}

\blindtext{}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{%
      $\text{%
        $((\valueintp[1]_t, \valueintp[p]_t))_{t=0,\dotsc,T}$%
      } = \texttt{solveValueFunction}$%
    }{%
      \hspace*{0mm}%
    }
      \State{$\valueintp[p]_{T+1} \gets \emptyset$}
      \Comment{dummy variable (is not used)}%
      \For{$t = T, T - 1, \dotsc, 0$}
        \State{%
          $\valueintp[1]_t \gets \text{%
            Initial regular sparse grid with no values%
          }$%
        }
        \State{%
          $\valueintp[1]_t \gets
          \texttt{optimize($t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$)}$%
        }
        \State{%
          $\valueintp[1]_t \gets
          \texttt{refine($t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$)}$%
        }
        \State{%
          $\valueintp[p]_t \gets
          \texttt{interpolate($\valueintp[1]_t$)}$%
        }
      \EndFor{}
    \EndFunction{}
  \end{algorithmic}
  \caption[TODO]{%
    TODO%
  }%
  \label{alg:financeSolveValueFunction}%
\end{algorithm}



\subsection{Optimization}
\label{sec:822optimization}

\todo{%
  certainty equivalence,
  parallelization,
  space transformation?
  value trafo?%
}

\blindtext{}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{$\valueintp[1]_t = \texttt{optimize}$}{%
      $t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$%
    }
      \State{%
        $(\state_t^{(k)})_{k=1,\dotsc,\ngp_t}
        \gets \text{grid of $\valueintp[1]_t$}$%
      }
      \For{$k = 1, \dotsc, \ngp_t$}
        \If{$\valueintp[1]_t(\state_t^{(k)})$ not already computed}
          \IfOneLine{$t = T$}{%
            $\valueintp[1]_T(\state_T^{(k)})
            \gets \texttt{computeKnownTerminalSolution($\state_T^{(k)}$)}$%
          }
          \ElseOneLine{%
            $\valueintp[1]_t(\state_t^{(k)})
            \gets \texttt{%
              optimizeSinglePoint(%
                $t$, $\state_t^{(k)}$, $\valueintp[p]_{t+1}$%
              )%
            }$%
          }
        \EndIf{}
      \EndFor{}
      \State{%
        Re-interpolate
        $(\valueintp[1]_t(\state_t^{(k)}))_{k=1,\dotsc,\ngp_t}$
        with piecewise linear functions%
      }
    \EndFunction{}
  \end{algorithmic}
  \caption[TODO]{%
    TODO%
  }%
  \label{alg:financeOptimize}%
\end{algorithm}



\subsection{Interpolation and Extrapolation}
\label{sec:823interpolation}

\todo{grid type, basis function type, why extrapolation necessary, extrapolation method}

\blindtext{}



\subsection{Quadrature}
\label{sec:824quadrature}

\blindtext{}



\subsection{Grid Generation}
\label{sec:825gridGeneration}

%The piecewise linear interpolant is used for the surplus-based
%grid generation,
%as the surpluses are easier to compute in the piecewise linear case,
%and they are more meaningful
%due to the integral representation formula \eqref{eq:surplusIntegral}.

\todo{gradient grids?}

\blindtext{}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{$\valueintp[1]_t = \texttt{refine}$}{%
      $t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$%
    }
      \For{$j = 1, \dotsc, \norefine_t$}
        \State{%
          Refine all grid points of $\valueintp[1]_t$ whose
          surplus is $< \refinetol_t$%
        }
        \IfOneLine{grid of $\valueintp[1]_t$ did not change}{\Break}
        \State{%
          $\valueintp[1]_t \gets
          \texttt{optimize($t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$)}$%
        }
      \EndFor{}
    \EndFunction{}
  \end{algorithmic}
  \caption[TODO]{%
    TODO%
  }%
  \label{alg:financeRefine}%
\end{algorithm}



\subsection{Policy Generation}
\label{sec:826policyGeneration}

\blindtext{}



\subsection{Euler Equation Errors}
\label{sec:827eulerEquationErrors}

\blindtext{}
