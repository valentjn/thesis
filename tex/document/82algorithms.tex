\section{Algorithms}
\label{sec:82algorithms}

This section gives an overview of the algorithms that
were used to implement the solution process of
the discretized Bellman equation \eqref{eq:gridBellman}.



\subsection{General Structure}
\label{sec:821generalStructure}

The general approach to solve dynamic portfolio choice models is as follows:
\begin{enumerate}
  \item
  Generation of value function interpolants $\valueintp_t$
  (\texttt{solveValueFunction}, \cref{alg:financeSolveValueFunction})
  
  \item
  Generation of optimal policy interpolants $\optpolicyintp_t$
  (\texttt{solvePolicy}, \cref{alg:financeSolvePolicy})
  
  \item
  Computation of Euler equation errors
  (\texttt{computeEulerErrors}, \cref{alg:computeEulerErrors})
\end{enumerate}
The separation of the solution processes for
the value function interpolants $\valueintp_t$
and the optimal policy interpolants $\optpolicyintp_t$
enables to generate different spatially adaptive sparse grids
for the value function and the optimal policies.
This is useful if the shapes of value function and optimal policies
have different characteristics.

In the following (\cref{%
  sec:822optimization,%
  sec:823interpolation,%
  sec:824quadrature,%
  sec:825gridGeneration%
}), we first describe the algorithmic details of
\texttt{solveValueFunction} (step 1).
The treatment of the other steps \texttt{solvePolicy} (step 2) and
\texttt{computeEulerErrors} (step 3) follows with
\cref{sec:826policyGeneration} and \cref{sec:827eulerEquationErrors},
respectively.

We track two interpolants $\valueintp[1]_t$ and $\valueintp[p]_t$
for each $t = 0, \dotsc, T$.
The former interpolates the value function data at the grid points
with the hierarchical piecewise linear basis
(used for the surplus-based grid generation),
while the latter interpolates the data with hierarchical B-splines
of higher order $p > 1$.
Each $\valueintp[\ast]_t$ ($\ast \in \{1, p\}$)
additionally stores the grid points $\state_t^{(k)}$
and the optimal policies $\optpolicyintp_t(\state_t^{(k)})$
at the grid points ($k = 1, \dotsc, \ngp_t$).
For simplicity, we do not pass them as separate data
to the algorithms.

\paragraph{\texttt{solveValueFunction}}

\Cref{alg:financeSolveValueFunction} shows \texttt{solveValueFunction},
which generates the value function interpolants
$\valueintp[1]_t$ and $\valueintp[p]_t$ ($t = 0, \dotsc, T$).
The algorithm follows a simple optimize--refine--interpolate scheme:
First, the Bellman equation \eqref{eq:gridBellman} is solved
on some initial sparse grid (\texttt{optimize}).
Then, we \texttt{refine} the grid spatially adaptively.
Finally, the data on the resulting grid are \texttt{interpolate}d
with hierarchical higher-order B-splines.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{%
      $\text{%
        $((\valueintp[1]_t, \valueintp[p]_t))_{t=0,\dotsc,T}$%
      } = \texttt{solveValueFunction}$%
    }{%
      \hspace*{0mm}%
    }
      \State{$\valueintp[p]_{T+1} \gets \emptyset$}
      \Comment{dummy variable (is not used)}%
      \For{$t = T, T - 1, \dotsc, 0$}
        \State{%
          $\valueintp[1]_t \gets \text{%
            Initial regular sparse grid with no values%
          }$%
        }
        \State{%
          $\valueintp[1]_t \gets
          \texttt{optimize($t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$)}$%
        }
        \State{%
          $\valueintp[1]_t \gets
          \texttt{refine($t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$)}$%
        }
        \State{%
          $\valueintp[p]_t \gets
          \texttt{interpolate($\valueintp[1]_t$)}$%
        }
      \EndFor{}
    \EndFunction{}
  \end{algorithmic}
  \caption[%
    Generation of value function interpolants (\texttt{solveValueFunction})%
  ]{%
    Generation of value function interpolants
    $\valueintp[1]_t$ (piecewise linear) and
    $\valueintp[p]_t$ (higher-order B-splines).%
  }%
  \label{alg:financeSolveValueFunction}%
\end{algorithm}

At the beginning of every iteration $t$,
the grid of the piecewise linear interpolant is reset
to an initial, possibly regular sparse grid.
It is also possible to reuse the grid from the
previous iteration $t + 1$.
Nevertheless, the results we then obtain become worse,
likely due to the different characteristics of $\valueintp[1]_t$
for different $t$ (e.g., kinks).

The higher-order B-spline interpolant
$\valueintp[p]_{t+1}$ of the previous iteration $t+1$ is used
for the \rhs of the Bellman equation \eqref{eq:gridBellman},
if $t < T$.
In the first iteration $t = T$,
there is no such interpolant.
However, it is not needed anyway, as the exact terminal solution
$\valuefcn_T$ is assumed to be explicitly known.



\subsection{Optimization}
\label{sec:822optimization}

\todo{%
  certainty equivalence,
  parallelization,
  space transformation?
  value trafo?%
}

\blindtext{}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{$\valueintp[1]_t = \texttt{optimize}$}{%
      $t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$%
    }
      \State{%
        $(\state_t^{(k)})_{k=1,\dotsc,\ngp_t}
        \gets \text{grid of $\valueintp[1]_t$}$%
      }
      \For{$k = 1, \dotsc, \ngp_t$}
        \If{$\valueintp[1]_t(\state_t^{(k)})$ not previously computed}
          \IfOneLine{$t = T$}{%
            $\valueintp[1]_T(\state_T^{(k)})
            \gets \texttt{computeKnownTerminalSolution($\state_T^{(k)}$)}$%
          }
          \ElseOneLine{%
            $\valueintp[1]_t(\state_t^{(k)})
            \gets \texttt{%
              optimizeSinglePoint(%
                $t$, $\state_t^{(k)}$, $\valueintp[p]_{t+1}$%
              )%
            }$%
          }
        \EndIf{}
      \EndFor{}
      \State{%
        Re-interpolate
        $(\valueintp[1]_t(\state_t^{(k)}))_{k=1,\dotsc,\ngp_t}$
        with piecewise linear functions%
      }
    \EndFunction{}
  \end{algorithmic}
  \caption[Evaluation of the value function (\texttt{optimize})]{%
    Evaluation of the value function at all
    grid points $\state_t^{(k)}$ of $\valueintp[1]_t$
    at which the value function has not been evaluated yet.
    Note that the argument $\valueintp[p]_{t+1}$ is not used
    if $t = T$.%
  }%
  \label{alg:financeOptimize}%
\end{algorithm}



\subsection{Interpolation and Extrapolation}
\label{sec:823interpolation}

\todo{%
  grid type, basis function type,
  why extrapolation necessary, extrapolation method%
}

\blindtext{}



\subsection{Quadrature}
\label{sec:824quadrature}

\blindtext{}



\subsection{Grid Generation}
\label{sec:825gridGeneration}

%The piecewise linear interpolant is used for the surplus-based
%grid generation,
%as the surpluses are easier to compute in the piecewise linear case,
%and they are more meaningful
%due to the integral representation formula \eqref{eq:surplusIntegral}.

\todo{gradient grids?}

\blindtext{}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{$\valueintp[1]_t = \texttt{refine}$}{%
      $t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$%
    }
      \For{$j = 1, \dotsc, \norefine_t$}
        \State{%
          Refine all grid points of $\valueintp[1]_t$ whose
          surplus is $< \refinetol_t$%
        }
        \IfOneLine{grid of $\valueintp[1]_t$ did not change}{\Break}
        \State{%
          $\valueintp[1]_t \gets
          \texttt{optimize($t$, $\valueintp[1]_t$, $\valueintp[p]_{t+1}$)}$%
        }
      \EndFor{}
    \EndFunction{}
  \end{algorithmic}
  \caption[TODO]{%
    TODO%
  }%
  \label{alg:financeRefine}%
\end{algorithm}



\subsection{Policy Generation}
\label{sec:826policyGeneration}

\blindtext{}



\subsection{Euler Equation Errors}
\label{sec:827eulerEquationErrors}

\blindtext{}
