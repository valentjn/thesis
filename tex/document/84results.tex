\section{Implementation and Numerical Results}
\label{sec:84results}

\minitoc[13mm]{65mm}{6}

\parbox{1em}{}
\vspace{-3em}



\printornamentsfalse
\subsection{Implementation}
\label{sec:841implementation}
\printornamentstrue

\paragraph{Parameter values and basis functions}

We use
a risk aversion factor of $\riskav = 3.5$,
a patience factor of $\patience = 0.97$,
a transaction cost rate of $\tac = \SI{1}{\percent}$, and
a minimum consumption of $\normconsume_{\min} = 0.001$.
The bond and stock return rates are taken from \cite{Cai10Stable}.
The models are solved for $T = 6$ time steps;
this number suffices to show all relevant numerical effects and results,
while keeping the computational effort at a reasonable level.
As higher-order B-spline basis functions,
we use the hierarchical weakly fundamental not-a-knot splines
$\bspl[\wfs,\nak]{\*l,\*i}{p}$ of cubic degree $p = 3$
to enable hierarchization with the unidirectional principle.

\vspace*{-0.5em}

\paragraph{Software}

The dynamic portfolio choice models were solved using a self-written
MATLAB framework.
The object-oriented framework was designed in such a way that
not only transaction costs problems,
but many other types of dynamic portfolio choice models can be handled.
For instance, the base class \texttt{LifecycleProblem} provides
an interface with abstract functions such as
\texttt{computeTerminalValueFunction} and
\texttt{computeStateTransition}.
The actual functionality implemented in the base class strongly resembles
the algorithms presented in \cref{sec:82algorithms}.
This is not only desirable from a modeling perspective,
but also facilitates future usage by other researchers.
For creating (hierarchization) and evaluating sparse grid interpolants,
the sparse grid toolbox \sgpp was used \cite{Pflueger10Spatially}.%
\footnote{%
  \url{http://sgpp.sparsegrids.org/}%
}
The emerging optimization problems were solved using
sequential quadratic programming methods supplied by the
NAG Toolbox for MATLAB.%
\footnote{%
  \url{https://www.nag.com/}%
}
To avoid getting stuck in local minima,
we repeat the optimization process for a varying number
of initial multi-start points (in the range of a few dozens).
All runtimes were measured on a shared memory computer
with 144 threads on 4x Intel Xeon E7-8880v3 (72 cores, 144 threads).

\paragraph{Error measures}

To assess the quality of the resulting value and policy functions,
we use two error measures:
Euler equation error and policy error.
The weighted Euler equation error $\weightedeulererror_t(\normstate_t)$
measures the violation of the first-order optimality conditions,
derived as above.
The policy error is the difference
$\optnormpolicyref_t(\state_t) - \optnormpolicyintp_t(\state_t)$
of the optimal policy to some reference.
Both error measures can be analyzed pointwise or
via their $\Ltwo$ norms, where for the policy error,
we take the mean of the relative $\Ltwo$ error:
\begin{equation}
  \policyerror_t
  := \frac{1}{m_{\policy}} \sum_{j=1}^{m_{\policy}}
  \frac{
    \normLtwo{\optnormpolicyentryref_{t,j} - \optnormpolicyentryintp_{t,j}}
  }{
    \normLtwo{\optnormpolicyentryref_{t,j}}
  }.
\end{equation}
It suffices to consider $t = 0$, as both error measures
usually grow backwards in time due to the dynamic programming approach.



\subsection{Error Sources}
\label{sec:842errorSources}

% high-level explanation of accumulation of errors over time

In this application, there are the following error sources:

\begin{enumerate}[label=E\arabic*.,ref=E\arabic*,leftmargin=2.7em]
  \item
  Interpolation of the value function
  (i.e., $\normcetvalueintp_{t+1} \not= \normcetvaluefcn_{t+1}$)
  
  \item
  Interpolation of the policy functions
  (i.e., $\optnormpolicyintp_t \not= \optnormpolicyfcn_t$)
  
  \item
  Extrapolation errors
  (i.e., $
  \normcetvalueintp_{t+1}(\state_{t+1})
  \not= \normcetvaluefcn_{t+1}(\state_{t+1})
  $)
  
  \item
  Errors from state space cropping
  (i.e., Euler errors do not vanish for exact solution)
  
  \item
  Optimization error
  (i.e., the global minimum found by the optimizer is inaccurate)
  
  \item
  Quadrature error
  ($
  \expectation[t]{\cdots}
  \not= \sum_{j=1}^{m_{\quadweight}} \quadweight_t^{(j)}
  [\cdots](\stochastic_t^{(j)})
  $)
  
  \item
  Floating-point rounding errors
  (i.e., arithmetical operations are inaccurate)
\end{enumerate}
Due to the dynamic programming scheme,
the combination of all errors accumulates over $t$.
For instance, if the optimization does not find the global optimum
exactly or it only finds a local one for the time $t + 1$,
the error propagates from the interpolant $\normcetvalueintp_{t+1}$
on the right-hand side of the Bellman equation
\eqref{eq:normalizedTCPBellmanEquation} to $\normcetvalueintp_t$
on the left-hand side, and so on.
If the system does not damp these errors,
the error might become stronger and stronger backwards in time $t$.



\subsection{Numerical Results}
\label{sec:843results}

\paragraph{Reference solution}

We use full grid solutions as reference solutions,
i.e., $\{\state_t^{(k)} \mid k = 1, \dotsc, \ngp_t\} = \fgset{n,d}$
for some fixed level $n \in \nat$ for all $t = 0, \dotsc, T$.
Obviously, this is only computationally feasible
for low dimensionalities $d$ due to the curse of dimensionality.
For each $d$,
\cref{tbl:financeSolutionFullRegularSparseGrids}
(see \cref{chap:a40financeDetails})
contains full grid solutions of different levels,
where the solution with the highest level is used as reference solution.
The reference solution for $d = 2$ is shown in
\cref{fig:financeSolution2DReference}.
Unfortunately, only full grid solutions up to $d = 3$ could be computed
due to excessive runtime for $d \ge 4$,
which means that policy errors can only be given for $d = 2$ or $d = 3$.
This underlines the need for sophisticated
discretization techniques such as sparse grids.

\begin{figure}
  \makebox[49mm][r]{%
    \includegraphics{financeSolution2D_1}%
  }%
  \hfill%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution2D_2}%
  }%
  \hfill%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution2D_3}%
  }%
  \\[1mm]%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution2D_4}%
  }%
  \hfill%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution2D_5}%
  }%
  \hfill%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution2D_6}%
  }%
  \caption[Reference solution for the two-dimensional TCP]{%
    Reference solution for the transaction costs problem
    with $d = 2$ stocks.
    Shown are the value function $\normcetvalueref_t$ \emph{(top left)} and the
    optimal policy $\optnormpolicyref_t$ for the initial time step $t = 0$.%
  }%
  \label{fig:financeSolution2DReference}%
\end{figure}

\paragraph{Convergence of 1D, 2D, and 3D solutions}

% FG vs. regular SG vs. adaptive SG
% Euler eq. errors, policy errors?

\Cref{fig:financeEulerError} shows the convergence of the
$\Ltwo$ norm $\normLtwo{\weightedeulererror_0}$
weighted Euler equation error for $t = 0$ for the reference full grids,
regular sparse grids, and spatially adaptive sparse grids.
For this and the following plots,
the value function grid is kept unchanged,
while the mean number $\ngp_t$ of policy grid points increases
with decreasing refinement threshold $\refinetol_t$.

\begin{figure}
  \includegraphics{financeEulerError_4}%
  \\[2mm]%
  \subcaptionbox{%
    $d = 1$%
  }[48mm]{%
    \includegraphics{financeEulerError_1}%
  }%
  \hfill%
  \subcaptionbox{%
    $d = 2$%
  }[48mm]{%
    \includegraphics{financeEulerError_2}%
  }%
  \hfill%
  \subcaptionbox{%
    $d = 3$%
  }[48mm]{%
    \includegraphics{financeEulerError_3}%
  }%
  \caption[Convergence of the weighted Euler equation error]{%
    Convergence of the $\Ltwo$ norm $\normLtwo{\weightedeulererror_0}$
    of the weighted Euler equation error for $t = 0$ for
    full grids \emph{\textcolor{C0}{(blue)},}
    regular sparse grids \emph{\textcolor{C1}{(red)},} and
    spatially adaptive sparse grids \emph{\textcolor{C2}{(yellow)}.}%
  }%
  \label{fig:financeEulerError}%
\end{figure}



\begin{figure}
  \subcaptionbox{%
    $\normcetvalueintp_t$%
  }[48mm]{%
    \includegraphics{financeSolution2D_7}%
  }%
  \hfill%
  \subcaptionbox{%
    $\normbuy[\sparse]_{t,1}$%
  }[48mm]{%
    \includegraphics{financeSolution2D_8}%
  }%
  \hfill%
  \subcaptionbox{%
    $\normbuy[\sparse]_{t,2}$%
  }[48mm]{%
    \includegraphics{financeSolution2D_9}%
  }%
  \\[2mm]%
  \subcaptionbox{%
    $\normsell[\sparse]_{t,1}$%
  }[48mm]{%
    \includegraphics{financeSolution2D_10}%
  }%
  \hfill%
  \subcaptionbox{%
    $\normsell[\sparse]_{t,2}$%
  }[48mm]{%
    \includegraphics{financeSolution2D_11}%
  }%
  \hfill%
  \subcaptionbox{%
    $\normbond_t^{\sparse}$%
  }[48mm]{%
    \includegraphics{financeSolution2D_12}%
  }%
  \caption[Sparse grid solution for the two-dimensional TCP]{%
    Spatially adaptive sparse grid solution for the transaction costs problem
    with $d = 2$ stocks.
    \vspace{-0.15em}%
    Shown are the value function $\normcetvalueref_t$ \emph{(top left)} and the
    optimal policy $\optnormpolicyref_t$ for the initial time step $t = 0$,
    together with the corresponding grid points \emph{(dots).}
    The color coding is the same as in
    \cref{fig:financeSolution2DReference}.%
  }%
  \label{fig:financeSolution2DSparseGrid}%
\end{figure}

\dummytext[2]{}

\paragraph{Pointwise error}

\begin{figure}
  \includegraphics{financePointwiseError_4}%
  \\[2mm]%
  \subcaptionbox{%
    TODO%
  }[49mm]{%
    \includegraphics{financePointwiseError_1}%
  }%
  \hfill%
  \subcaptionbox{%
    TODO%
  }[49mm]{%
    \includegraphics{financePointwiseError_2}%
  }%
  \hfill%
  \subcaptionbox{%
    TODO%
  }[49mm]{%
    \includegraphics{financePointwiseError_3}%
  }%
  \caption[TODO]{%
    TODO%
  }%
  \label{fig:financePointwiseError}%
\end{figure}

\dummytext[3]{}

\paragraph{4D and 5D solutions}

\dummytext[2]{}

\paragraph{Monte Carlo simulation}

% Portfolio-Gewichte, die Sharp-Ratio maximieren (Einheit Überrendite pro Einheit Risiko)
%loadResult(22)
%problem.plotLifecycleProfile(simulation.state, simulation.discreteState, simulation.policy, simulation.shock)
%A = [0.0256, 0.00576, 0.00288, 0.00176; ...
%0.00576, 0.0324, 0.0090432, 0.010692; ...
%0.00288, 0.0090432, 0.04, 0.0132; ...
%0.00176, 0.010692, 0.0132, 0.0484];
%A
%b = diag(A)
%b = sqrt(diag(A))
%format long
%b = sqrt(diag(A))
%format short
%b = sqrt(diag(A))
%A
%cor(A)
%corr(A)
%doc corr
%corr(A(1:3,1:3))
%B = corr(A); B = B(1:3,1:3);
%B = corr(A); B = B(1:3,1:3)
%corrcov(A)
%corrcov(A(1:3,1:3))
%[B, sigma] = corrcov(A(1:3,1:3))
%b = [0.0572, 0.0638, 0.07, 0.0764]
%diff(b)
%rf = problem.Return.riskfreeRate
%b = b(1:3);
%b
%(b-rf)./sigma
%(b-rf)/sigma
%(b-rf)./sigma
%(b-rf)./sigma'
%ver
%x = 1/3*ones(1,3)
%(x*b'-rf)./(x*sigma'*x')
%(x*b'-rf)./(x*sigma*x')
%x*b'
%rf
%x*sigma
%sigma
%A
%(x*b'-rf)./(x*A(1:3,1:3)*x')
%f = @(x) (x*b'-rf)./(x*A(1:3,1:3)*x')
%help fminbnd
%help fmincon
%fmincon(f, [1/3 1/3 1/3], [], [], [], [], [0 0 0], [1 1 1])
%sum(ans)
%xopt = fmincon(f, [1/3 1/3 1/3], [], [], [], [], [0 0 0], [1 1 1])
%f(xopt)
%xopt = fmincon(-f, [1/3 1/3 1/3], [], [], [], [], [0 0 0], [1 1 1])
%f = @(x) -(x*b'-rf)./(x*A(1:3,1:3)*x')
%xopt = fmincon(f, [1/3 1/3 1/3], [], [], [], [], [0 0 0], [1 1 1])
%sum(xopt)
%xopt = fmincon(f, [1/3 1/3 1/3], [], [], [1 1 1], 1, [0 0 0], [1 1 1])
%sum(xopt)
%1.8/(1.45+1.45+1.8)
%1.45/(1.45+1.45+1.8)
%A
%A = diag(diag(A))
%xopt = fmincon(f, [1/3 1/3 1/3], [], [], [1 1 1], 1, [0 0 0], [1 1 1])

% certainty-equivalent consumption
% mit B-splines und linearen Funktionen

\begin{figure}
  \includegraphics{financeSimulation_5}%
  \\[2mm]%
  \subcaptionbox{%
    TODO%
  }[48mm]{%
    \includegraphics{financeSimulation_1}%
  }%
  \hfill%
  \subcaptionbox{%
    TODO%
  }[48mm]{%
    \includegraphics{financeSimulation_2}%
  }%
  \hfill%
  \subcaptionbox{%
    TODO%
  }[48mm]{%
    \includegraphics{financeSimulation_3}%
  }%
  \\[2mm]%
  \subcaptionbox{%
    TODO%
  }[48mm]{%
    \includegraphics{financeSimulation_4}%
  }%
  \hfill%
  \begin{minipage}[b]{92mm}%
    \caption[TODO]{%
      TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
      TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
      TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
      TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO%
    }%
    \vspace*{-6.3mm}%
    \label{fig:financeSimulation}%
  \end{minipage}%
\end{figure}

\dummytext[2]{}

\paragraph{Complexity and runtime analysis}

% analyze runtime behavior over N (fixed d) and d

% (e-mail 2018-01-03)
%Runtime of one optimize() run
%- -----------------------------
%O(#New state grid points
%* #Optimization iterations
%* #Quadrature points
%* #Old state grid points
%* #State dimensions
%* Runtime of one 1D basis evaluation)
%
%where
%#(Optimization iterations) depends on #(Policy dimensions),
%#(Policy dimensions) = 2 * #Stocks + 1
%#(State dimensions) = #Stocks + 1
%
%(modulo extrapolations)

\begin{equation}
  \landauO{
    % for every time step
    T
    % for every grid point of new time step
    \cdot \ngp_t
    % for every optimization iteration
    \cdot \text{\#optimizer iterations}
    \cdot
    \underbrace{
      % for every gradient entry of the objective function
      m_{\policy}
      % for every quadrature point
      \cdot m_{\stochastic}
      \cdot
      \overbrace{
        % for every summand of the sparse grid function
        % (grid point of old time step)
        \ngp_{t+1}
        % for every tensor product factor
        \cdot m_{\state}
        % for every B-spline summand
        \cdot p
      }^{\mathclap{\text{evaluation of interpolant}}}
    }_{\text{evaluation of objective gradient}}\,
  }
\end{equation}

\#optimizer iterations contains multi-start points!

\begin{equation}
  \landauO{
    T
    \cdot
    2^n n^{d-1}
    \cdot
    2^n n^{d-1}
    \cdot
    (2d + 1)
    \cdot
    2^n n^{d-1}
    \cdot
    2^n n^{d-1}
    \cdot
    d
    \cdot
    p
  }
  = \landauO{Tdp 2^{4n} n^{4d-4}}??
\end{equation}

\dummytext[3]{}

\paragraph{Impact of the B-spline degree}

\dummytext[3]{}

\paragraph{Comparing exact gradients to finite differences}

\dummytext[3]{}
