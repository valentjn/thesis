\section{Implementation and Numerical Results}
\label{sec:84results}

\minitoc[11.5mm]{65mm}{6}

\parbox{1em}{}
\vspace{-3em}



\printornamentsfalse
\subsection{Implementation}
\printornamentstrue

\paragraph{Parameter values and basis functions}

We use
a risk aversion factor of $\riskav = 3.5$,
a patience factor of $\patience = 0.97$,
a transaction cost rate of $\tac = \SI{1}{\percent}$, and
a minimum consumption of $\normconsume_{\min} = 0.001$.
The bond and stock return rates are taken from \cite{Cai10Stable}.
The models are solved for $T = 6$ time steps;
this number suffices to show all relevant numerical effects and results,
while keeping the computational effort at a reasonable level.
As higher-order B-spline basis functions,
we use the hierarchical weakly fundamental not-a-knot splines
$\bspl[\wfs,\nak]{\*l,\*i}{p}$ of cubic degree $p = 3$
to enable hierarchization with the unidirectional principle.

\vspace*{-0.5em}

\paragraph{Software}

The dynamic portfolio choice models were solved using a self-written
MATLAB framework.
The object-oriented framework was designed in such a way that
not only transaction costs problems,
but many other types of dynamic portfolio choice models can be handled.
For instance, the base class \texttt{LifecycleProblem} provides
an interface with abstract functions such as
\texttt{computeTerminalValueFunction} and
\texttt{computeStateTransition}.
The actual functionality implemented in the base class strongly resembles
the algorithms presented in \cref{sec:82algorithms}.
This is not only desirable from a modeling perspective,
but also facilitates future usage by other researchers.
For creating (hierarchization) and evaluating sparse grid interpolants,
the sparse grid toolbox \sgpp was used \cite{Pflueger10Spatially}.%
\footnote{%
  \url{http://sgpp.sparsegrids.org/}%
}
The emerging optimization problems were solved using
sequential quadratic programming methods supplied by the
NAG Toolbox for MATLAB.%
\footnote{%
  \url{https://www.nag.com/}%
}
Runtimes were measured on a shared memory computer
with 144 threads on 4x Intel Xeon E7-8880v3 (72 cores, 144 threads).

\paragraph{Error measures}

To assess the quality of the resulting value and policy functions,
we use two error measures:
Euler equation error and policy error.
The weighted Euler equation error $\weightedeulererror_t(\normstate_t)$
measures the violation of the first-order optimality conditions,
derived as above.
The policy error is the difference
$\optnormpolicyref_t(\state_t) - \optnormpolicyintp_t(\state_t)$
of the optimal policy to some reference.
Both error measures can be analyzed pointwise or
via their $\Ltwo$ norms, where for the policy error,
we take the mean of the relative $\Ltwo$ error:
\begin{equation}
  \policyerror_t
  := \frac{1}{m_{\policy}} \sum_{j=1}^{m_{\policy}}
  \frac{
    \normLtwo{\optnormpolicyentryref_{t,j} - \optnormpolicyentryintp_{t,j}}
  }{
    \normLtwo{\optnormpolicyentryref_{t,j}}
  }.
\end{equation}
It suffices to consider $t = 0$, as both error measures
usually grow backwards in time due to the dynamic programming approach.



\subsection{Numerical Results}

\paragraph{Reference solution}

We use full grid solutions as reference solutions,
i.e., $\{\state_t^{(k)} \mid k = 1, \dotsc, \ngp_t\} = \fgset{n,d}$
for some fixed level $n \in \nat$ for all $t = 0, \dotsc, T$.
Obviously, this is only computationally feasible
for low dimensionalities $d$ due to the curse of dimensionality.
For each $d$,
\cref{tbl:financeSolutionFullRegularSparseGrids}
(see \cref{chap:a40financeDetails})
contains full grid solutions of different levels,
where the solution with the highest level is used as reference solution.
Unfortunately, only full grid solutions up to $d = 3$ could be computed
due to excessive runtime for $d \ge 4$,
which means that policy errors can only be given for $d = 2$ or $d = 3$.
This underlines the need for sophisticated
discretization techniques such as sparse grids.

\begin{figure}
  \makebox[49mm][r]{%
    \includegraphics{financeSolution_1}%
  }%
  \hfill%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution_2}%
  }%
  \hfill%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution_3}%
  }%
  \\[1mm]%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution_4}%
  }%
  \hfill%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution_5}%
  }%
  \hfill%
  \makebox[49mm][r]{%
    \includegraphics{financeSolution_6}%
  }%
  \caption[TODO]{%
    TODO%
  }%
  \label{fig:TODO}%
\end{figure}

\paragraph{Solution on regular sparse grids}

\dummytext[8]{}

\paragraph{Solution on spatially adaptive sparse grids}

\dummytext[8]{}

\paragraph{Comparison with piecewise linear functions}

\dummytext[8]{}

\paragraph{Monte Carlo simulation}

% Portfolio-Gewichte, die Sharp-Ratio maximieren (Einheit Ãœberrendite pro Einheit Risiko)
%loadResult(22)
%problem.plotLifecycleProfile(simulation.state, simulation.discreteState, simulation.policy, simulation.shock)
%A = [0.0256, 0.00576, 0.00288, 0.00176; ...
%0.00576, 0.0324, 0.0090432, 0.010692; ...
%0.00288, 0.0090432, 0.04, 0.0132; ...
%0.00176, 0.010692, 0.0132, 0.0484];
%A
%b = diag(A)
%b = sqrt(diag(A))
%format long
%b = sqrt(diag(A))
%format short
%b = sqrt(diag(A))
%A
%cor(A)
%corr(A)
%doc corr
%corr(A(1:3,1:3))
%B = corr(A); B = B(1:3,1:3);
%B = corr(A); B = B(1:3,1:3)
%corrcov(A)
%corrcov(A(1:3,1:3))
%[B, sigma] = corrcov(A(1:3,1:3))
%b = [0.0572, 0.0638, 0.07, 0.0764]
%diff(b)
%rf = problem.Return.riskfreeRate
%b = b(1:3);
%b
%(b-rf)./sigma
%(b-rf)/sigma
%(b-rf)./sigma
%(b-rf)./sigma'
%ver
%x = 1/3*ones(1,3)
%(x*b'-rf)./(x*sigma'*x')
%(x*b'-rf)./(x*sigma*x')
%x*b'
%rf
%x*sigma
%sigma
%A
%(x*b'-rf)./(x*A(1:3,1:3)*x')
%f = @(x) (x*b'-rf)./(x*A(1:3,1:3)*x')
%help fminbnd
%help fmincon
%fmincon(f, [1/3 1/3 1/3], [], [], [], [], [0 0 0], [1 1 1])
%sum(ans)
%xopt = fmincon(f, [1/3 1/3 1/3], [], [], [], [], [0 0 0], [1 1 1])
%f(xopt)
%xopt = fmincon(-f, [1/3 1/3 1/3], [], [], [], [], [0 0 0], [1 1 1])
%f = @(x) -(x*b'-rf)./(x*A(1:3,1:3)*x')
%xopt = fmincon(f, [1/3 1/3 1/3], [], [], [], [], [0 0 0], [1 1 1])
%sum(xopt)
%xopt = fmincon(f, [1/3 1/3 1/3], [], [], [1 1 1], 1, [0 0 0], [1 1 1])
%sum(xopt)
%1.8/(1.45+1.45+1.8)
%1.45/(1.45+1.45+1.8)
%A
%A = diag(diag(A))
%xopt = fmincon(f, [1/3 1/3 1/3], [], [], [1 1 1], 1, [0 0 0], [1 1 1])

% certainty-equivalent consumption
% mit B-splines und linearen Funktionen

\dummytext[8]{}
